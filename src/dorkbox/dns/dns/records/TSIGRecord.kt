/*
 * Copyright 2021 dorkbox, llc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dorkbox.dns.dns.records

import dorkbox.dns.dns.Compression
import dorkbox.dns.dns.DnsInput
import dorkbox.dns.dns.DnsOutput
import dorkbox.dns.dns.Name
import dorkbox.dns.dns.constants.DnsRecordType
import dorkbox.dns.dns.constants.DnsResponseCode
import dorkbox.dns.dns.constants.DnsResponseCode.TSIGstring
import dorkbox.dns.dns.utils.Options.check
import dorkbox.dns.dns.utils.Tokenizer
import dorkbox.os.OS.LINE_SEPARATOR
import java.io.IOException
import java.util.*

/**
 * Transaction Signature - this record is automatically generated by the
 * resolver.  TSIG records provide transaction security between the
 * sender and receiver of a message, using a shared key.
 *
 * @author Brian Wellington
 * @see TSIG
 */
class TSIGRecord : DnsRecord {
    /**
     * Returns the shared key's algorithm
     */
    lateinit var algorithm: Name
        private set

    /**
     * Returns the time that this record was generated
     */
    lateinit var timeSigned: Date
        private set

    /**
     * Returns the time fudge factor
     */
    var fudge = 0
        private set

    /**
     * Returns the signature
     */
    lateinit var signature: ByteArray
        private set

    /**
     * Returns the original message ID
     */
    var originalID = 0
        private set

    /**
     * Returns the extended error
     */
    var error = 0
        private set

    /**
     * Returns the other data
     */
    var other: ByteArray? = null
        private set

    internal constructor() {}

    override val `object`: DnsRecord
        get() = TSIGRecord()

    @Throws(IOException::class)
    override fun rrFromWire(`in`: DnsInput) {
        algorithm = Name(`in`)
        val timeHigh = `in`.readU16().toLong()
        val timeLow = `in`.readU32()
        val time = (timeHigh shl 32) + timeLow
        timeSigned = Date(time * 1000)
        fudge = `in`.readU16()
        val sigLen = `in`.readU16()
        signature = `in`.readByteArray(sigLen)
        originalID = `in`.readU16()
        error = `in`.readU16()
        val otherLen = `in`.readU16()
        other = if (otherLen > 0) {
            `in`.readByteArray(otherLen)
        } else {
            null
        }
    }

    override fun rrToWire(out: DnsOutput, c: Compression?, canonical: Boolean) {
        algorithm.toWire(out, null, canonical)
        val time = timeSigned.time / 1000
        val timeHigh = (time shr 32).toInt()
        val timeLow = time and 0xFFFFFFFFL
        out.writeU16(timeHigh)
        out.writeU32(timeLow)
        out.writeU16(fudge)
        out.writeU16(signature.size)
        out.writeByteArray(signature)
        out.writeU16(originalID)
        out.writeU16(error)
        if (other != null) {
            out.writeU16(other!!.size)
            out.writeByteArray(other!!)
        } else {
            out.writeU16(0)
        }
    }

    /**
     * Converts rdata to a String
     */
    override fun rrToString(sb: StringBuilder) {
        sb.append(algorithm)
        sb.append(" ")
        if (check("multiline")) {
            sb.append("(").append(LINE_SEPARATOR).append("\t")
        }
        sb.append(timeSigned.time / 1000)
        sb.append(" ")
        sb.append(fudge)
        sb.append(" ")
        sb.append(signature.size)
        if (check("multiline")) {
            sb.append(LINE_SEPARATOR)
            sb.append(Base64.getMimeEncoder().encodeToString(signature))
        } else {
            sb.append(" ")
            sb.append(Base64.getEncoder().encodeToString(signature))
        }
        sb.append(" ")
        sb.append(TSIGstring(error))
        sb.append(" ")
        if (other == null) {
            sb.append(0)
        } else {
            sb.append(other!!.size)
            if (check("multiline")) {
                sb.append(LINE_SEPARATOR).append(LINE_SEPARATOR).append(LINE_SEPARATOR).append("\t")
            } else {
                sb.append(" ")
            }
            if (error == DnsResponseCode.BADTIME) {
                if (other!!.size != 6) {
                    sb.append("<invalid BADTIME other data>")
                } else {
                    val time =
                        ((other!![0].toInt() and 0xFF).toLong() shl 40) + ((other!![1].toInt() and 0xFF).toLong() shl 32) + (other!![2].toInt() and 0xFF shl 24) + (other!![3].toInt() and 0xFF shl 16) + (other!![4].toInt() and 0xFF shl 8) + (other!![5].toInt() and 0xFF)
                    sb.append("<server time: ")
                    sb.append(Date(time * 1000))
                    sb.append(">")
                }
            } else {
                sb.append("<")
                sb.append(Base64.getEncoder().encodeToString(other))
                sb.append(">")
            }
        }
        if (check("multiline")) {
            sb.append(" )")
        }
    }

    @Throws(IOException::class)
    override fun rdataFromString(st: Tokenizer, origin: Name?) {
        throw st.exception("no text format defined for TSIG")
    }

    /**
     * Creates a TSIG Record from the given data.  This is normally called by
     * the TSIG class
     *
     * @param alg The shared key's algorithm
     * @param timeSigned The time that this record was generated
     * @param fudge The fudge factor for time - if the time that the message is
     * received is not in the range [now - fudge, now + fudge], the signature
     * fails
     * @param signature The signature
     * @param originalID The message ID at the time of its generation
     * @param error The extended error field.  Should be 0 in queries.
     * @param other The other data field.  Currently used only in BADTIME
     * responses.
     *
     * @see TSIG
     */
    constructor(
        name: Name,
        dclass: Int,
        ttl: Long,
        alg: Name,
        timeSigned: Date,
        fudge: Int,
        signature: ByteArray,
        originalID: Int,
        error: Int,
        other: ByteArray?
    ) : super(name, DnsRecordType.TSIG, dclass, ttl) {
        algorithm = checkName("alg", alg)
        this.timeSigned = timeSigned
        this.fudge = checkU16("fudge", fudge)
        this.signature = signature
        this.originalID = checkU16("originalID", originalID)
        this.error = checkU16("error", error)
        this.other = other
    }

    companion object {
        private const val serialVersionUID = -88820909016649306L
    }
}
